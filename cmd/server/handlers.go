package main

import (
	"context"
	"errors"
	"fmt"
	"log/slog"

	"connectrpc.com/connect"
	"github.com/eljamo/libpass/v7/service"
	"github.com/eljamo/mempass-api/internal/config"
	mempassv1 "github.com/eljamo/mempass-api/internal/gen/mempass/v1" // generated by protoc-gen-connect-go
)

// PasswordServiceHandler handles password generation requests.
type PasswordServiceHandler struct {
	logger *slog.Logger
}

// GeneratePasswords handles the generation of passwords based on the request.
func (h *PasswordServiceHandler) GeneratePasswords(
	ctx context.Context,
	req *connect.Request[mempassv1.GeneratePasswordsRequest],
) (*connect.Response[mempassv1.GeneratePasswordsResponse], error) {
	h.logger.InfoContext(ctx, "GeneratePasswords request received")

	// Generate configuration from request
	cfg, err := config.Generate(req)
	if err != nil {
		h.logger.ErrorContext(ctx, "failed to generate config", slog.String("error", err.Error()))
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	// Create password generator service
	svc, err := service.NewPasswordGeneratorService(cfg)
	if err != nil {
		h.logger.ErrorContext(ctx, "failed to create password generator service", slog.String("error", err.Error()))
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	// Generate passwords using the wrapper function
	pws, err := h.generatePasswordsWithContext(ctx, svc)
	if err != nil {
		h.logger.ErrorContext(ctx, "failed to generate passwords", slog.String("error", err.Error()))
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	h.logger.InfoContext(ctx, "passwords generated successfully", slog.Int("count", len(pws)))
	return connect.NewResponse(&mempassv1.GeneratePasswordsResponse{Passwords: pws}), nil
}

// generatePasswordsWithContext handles the context while generating passwords.
func (h *PasswordServiceHandler) generatePasswordsWithContext(ctx context.Context, svc *service.DefaultPasswordGeneratorService) ([]string, error) {
	type result struct {
		passwords []string
		err       error
	}

	resultChan := make(chan result, 1)

	go func() {
		pws, err := svc.Generate()
		resultChan <- result{passwords: pws, err: err}
	}()

	select {
	case <-ctx.Done():
		h.logger.WarnContext(ctx, "Password generation canceled")
		return nil, fmt.Errorf("context canceled: %w", ctx.Err())
	case res := <-resultChan:
		if errors.Is(res.err, context.Canceled) {
			h.logger.WarnContext(ctx, "Password generation canceled by context")
			return nil, res.err
		}
		return res.passwords, res.err
	}
}
